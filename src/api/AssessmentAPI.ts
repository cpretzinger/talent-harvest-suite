import { supabase } from "@/integrations/supabase/client";
import { Question, Assessment, AssessmentResult, Profile, CategoryScore, ScoreLevel } from "@/types/assessment";

export class AssessmentAPI {
  async getAssessment(assessmentId: string): Promise<Assessment | null> {
    const { data, error } = await supabase
      .from('assessments')
      .select(`
        *,
        questions (*)
      `)
      .eq('id', assessmentId)
      .single();

    if (error) throw error;
    return data;
  }

  async submitAssessment(
    userId: string,
    assessmentId: string,
    answers: Record<string, any>
  ): Promise<AssessmentResult> {
    // First, save the raw responses
    const { error: responseError } = await supabase
      .from('responses')
      .insert(
        Object.entries(answers).map(([questionId, answer]) => ({
          user_id: userId,
          assessment_id: assessmentId,
          question_id: questionId,
          answer
        }))
      );

    if (responseError) throw responseError;

    // Calculate the assessment results
    const results = await this.calculateResults(userId, assessmentId, answers);

    // Save the calculated results
    const { error: resultsError } = await supabase
      .from('assessment_results')
      .insert({
        user_id: userId,
        assessment_id: assessmentId,
        scores: results.scores,
        dimensional_balance: results.dimensional_balance,
        overall_profile: results.overall_profile
      });

    if (resultsError) throw resultsError;

    return results;
  }

  private async calculateResults(
    userId: string,
    assessmentId: string,
    answers: Record<string, any>
  ): Promise<AssessmentResult> {
    const { data: questions } = await supabase
      .from('questions')
      .select('*')
      .eq('assessment_id', assessmentId);

    const categoryScores = new Map<string, number>();
    let totalDIScore = 0;
    let totalSCScore = 0;

    questions?.forEach(question => {
      const answer = answers[question.id];
      const weightedScore = answer * question.weight;

      const currentScore = categoryScores.get(question.category) || 0;
      categoryScores.set(question.category, currentScore + weightedScore);

      if (['Decisive', 'Interactive'].includes(question.category)) {
        totalDIScore += weightedScore;
      } else if (['Stability', 'Cautious'].includes(question.category)) {
        totalSCScore += weightedScore;
      }
    });

    const dimensional_balance = {
      external: {
        empathy: categoryScores.get('Interactive') || 0,
        practicalThinking: categoryScores.get('Decisive') || 0,
        systemsJudgment: categoryScores.get('Cautious') || 0,
      },
      internal: {
        selfEsteem: totalDIScore / 2,
        roleAwareness: totalSCScore / 2,
        selfDirection: (totalDIScore + totalSCScore) / 4,
      },
    };

    return {
      id: '',  // Will be generated by Supabase
      user_id: userId,
      assessment_id: assessmentId,
      created_at: new Date().toISOString(),
      scores: Array.from(categoryScores.entries()).map(([category, score]) => ({
        category,
        score,
        level: this.calculateScoreLevel(score),
        insights: this.generateInsights(category, score),
      })),
      dimensional_balance,
      overall_profile: this.generateProfile(categoryScores)
    };
  }

  private calculateScoreLevel(score: number): ScoreLevel {
    if (score >= 9) return 'Excellent';
    if (score >= 8) return 'Very Good';
    if (score >= 7) return 'Good';
    if (score >= 6) return 'Fair';
    return 'Poor';
  }

  private generateInsights(category: string, score: number): string[] {
    // Implement insight generation based on category and score
    return [];
  }

  private generateProfile(scores: Map<string, number>): Record<string, any> {
    return {
      naturalStyle: { D: 0, I: 0, S: 0, C: 0 },
      adaptiveStyle: { D: 0, I: 0, S: 0, C: 0 },
      values: []
    };
  }
}